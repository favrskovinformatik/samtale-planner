
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>Samtaleplanl√¶gger</title>
    <script src="https://cdn.jsdelivr.net/gh/gzuidhof/coi-serviceworker@latest/coi-serviceworker.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.css" />
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.js"></script>
    <script>
      stlite.mount({
        requirements: ["pandas", "openpyxl", "xlsxwriter"],
        files: {
          "streamlit_app.py": `
import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
import io
import random

st.set_page_config(page_title="Samtaleplanl√¶gger", layout="wide", page_icon="üóìÔ∏è")

st.markdown("""
<style>
    [data-testid="stSidebar"] { min-width: 450px !important; }
    .stTextInput label, .stTextArea label, .stNumberInput label { font-weight: bold; }
    .example-table { margin-bottom: 20px; border-collapse: collapse; width: 100%; }
    .example-table td, .example-table th { border: 1px solid #ddd; padding: 8px; font-size: 0.9em; }
    .example-table th { background-color: #f2f2f2; text-align: left; }
</style>
""", unsafe_allow_html=True)

st.title("üóìÔ∏è Samtaleplanl√¶gger")

st.info("### 1. Forbered din Excel-fil")
st.markdown("""
S√∏rg for at dit regneark har pr√¶cis disse tre kolonneoverskrifter. Her er et eksempel p√•, hvordan en r√¶kke skal se ud:
""")

example_data = {
    "Elevnavn": ["Jonas Petersen"],
    "Elevid": ["1x 07"],
    "√ònsker": ["AG samfundsfag, SR, FH biologi, FH idr√¶t, GU"]
}
st.table(pd.DataFrame(example_data))

st.markdown("""
Regnearket kan godt have flere kolonner, men de bliver ignoreret. Det samme g√¶lder fagene - det er kun initialerne, som programmet bruger.
""")

st.sidebar.header("1. Indstillinger")
start_tid_input = st.sidebar.text_input("Starttidspunkt (tt.mm)", value="17.00")
varighed = st.sidebar.number_input("Varighed (min)", value=10, step=5)

st.sidebar.markdown("---")
st.sidebar.header("2. Lokaler & Logistik")
lokale_buffer = st.sidebar.number_input("Pause ved l√¶rerskift i lokale (min)", value=10, step=5)
default_lokaler = "101, 409, 308, 309, 310, 312, 313, 315, 317, 508, 509, 510, 511, 513, 320, 321, 322, 323, 324, 210, 211, 213, 215, 216, 217, 218, 219, 220, M√∏de 1, M√∏de 2, M√∏de 3, M√∏de 4, M√∏de 5"
lokale_str = st.sidebar.text_area("Lokaler (komma-separeret)", value=default_lokaler)

st.sidebar.markdown("---")
st.sidebar.header("3. Specifikke √∏nsker")
specifikke_tider_raw = st.sidebar.text_area("Vejledninger for specifikke l√¶rere og elever planl√¶gges fra dette tidspunkt (Format: ID=tt.mm)", placeholder="AB=17.30\\n1q 18=17.00")

def parse_tider(text_input):
    laaste_tider = {}
    if not text_input: return laaste_tider
    for line in text_input.split('\\n'):
        if '=' in line:
            parts = line.split('=')
            key = parts[0].strip()
            time_val = parts[1].strip().replace('.', ':')
            laaste_tider[key] = time_val
    return laaste_tider

def beregn_plan_med_strategi(df, start_str, lokaler_raw, spec_tider_dict, varighed_min, buffer_min, strategi_params):
    try:
        global_start = datetime.strptime(start_str.replace('.', ':'), "%H:%M")
        df = df.dropna(subset=['Elevnavn', 'Elevid', '√ònsker'])
        df['Elevid'] = df['Elevid'].astype(str).str.strip()
        df['Klasse'] = df['Elevid'].str[:2]
        
        opgaver_liste = []
        for _, row in df.iterrows():
            onsker = [x.strip() for x in str(row['√ònsker']).split(',') if x.strip()]
            for item in onsker:
                laer = item.split()[0]
                opgaver_liste.append({'Elevid': row['Elevid'], 'Elevnavn': row['Elevnavn'], 'L√¶rer': laer, 'Klasse': row['Klasse']})
        
        df_opgaver = pd.DataFrame(opgaver_liste)
        alle_laerere = df_opgaver['L√¶rer'].unique()
        alle_elever = df_opgaver['Elevid'].unique()

        laerer_fri = {l: global_start for l in alle_laerere}
        elev_fri = {e: global_start for e in alle_elever}
        
        # P√•f√∏r specifikke minimumsstarttider
        for k, v in spec_tider_dict.items():
            t = datetime.strptime(v, "%H:%M")
            if k in laerer_fri: laerer_fri[k] = t
            if k in elev_fri: elev_fri[k] = t
        
        # Smart klasse-gruppering: Hvis en elev i en klasse har specifik starttid, 
        # grupp√©r hele klassen omkring denne tid
        klasse_starttider = {}
        for klasse in df['Klasse'].unique():
            klasse_elever = df[df['Klasse'] == klasse]['Elevid'].unique()
            # Find om nogen i klassen har en specifik starttid
            spec_tider_i_klasse = [elev_fri[e] for e in klasse_elever if e in spec_tider_dict]
            if spec_tider_i_klasse:
                # Brug den seneste specifikke tid i klassen
                base_tid = max(spec_tider_i_klasse)
                offset_min = strategi_params.get('klasse_offset', 0)
                klasse_starttider[klasse] = base_tid + timedelta(minutes=offset_min)
        
        # Anvend klasse-gruppering p√• elever uden specifik starttid
        if strategi_params.get('klasse_gruppering', True):
            for e in alle_elever:
                if e not in spec_tider_dict:  # Kun elever uden specifik tid
                    elev_klasse = df[df['Elevid'] == e]['Klasse'].iloc[0]
                    if elev_klasse in klasse_starttider:
                        # Denne elev skal grupperes med sin klasse
                        elev_fri[e] = klasse_starttider[elev_klasse]

        if strategi_params.get('klasse_synkron', False):
            klasse_start_offset = strategi_params.get('klasse_offset', 0)
            for klasse in df['Klasse'].unique():
                klasse_elever = df[df['Klasse'] == klasse]['Elevid'].unique()
                klasse_start = global_start + timedelta(minutes=klasse_start_offset)
                for e in klasse_elever:
                    if e not in spec_tider_dict:
                        elev_fri[e] = klasse_start

        faerdig_plan = []
        resterende = df_opgaver.copy()
        
        prioritering = strategi_params.get('prioritering', 'belastning')
        
        if prioritering == 'belastning':
            laerer_prioritet = sorted(alle_laerere, key=lambda x: -len(df_opgaver[df_opgaver['L√¶rer']==x]))
        elif prioritering == 'laaste_foerst':
            laerer_prioritet = sorted(alle_laerere, key=lambda x: (0 if x in spec_tider_dict else 1, -len(df_opgaver[df_opgaver['L√¶rer']==x])))
        elif prioritering == 'elev_ventetid':
            # Prioriter l√¶rere hvis elever venter l√¶ngst
            laerer_ventetid = {}
            for laer in alle_laerere:
                laer_elever = df_opgaver[df_opgaver['L√¶rer'] == laer]['Elevid'].unique()
                max_vent = max([(laerer_fri[laer] - elev_fri[e]).total_seconds() / 60 for e in laer_elever])
                laerer_ventetid[laer] = max_vent
            laerer_prioritet = sorted(alle_laerere, key=lambda x: -laerer_ventetid[x])
        elif prioritering == 'random':
            laerer_prioritet = list(alle_laerere)
            random.shuffle(laerer_prioritet)
        else:
            laerer_prioritet = sorted(alle_laerere, key=lambda x: -len(df_opgaver[df_opgaver['L√¶rer']==x]))

        # Tildel samtaler
        for laer in laerer_prioritet:
            while True:
                mine = resterende[resterende['L√¶rer'] == laer]
                if mine.empty: break
                
                bedste_idx = -1
                tidligste_start = datetime.max
                
                # SIKRINGS-LOGIK: Find elev der er ledig med under 20 min ventetid
                for idx, row in mine.iterrows():
                    e = row['Elevid']
                    mulig_start = max(laerer_fri[laer], elev_fri[e])
                    ventetid = (mulig_start - elev_fri[e]).total_seconds() / 60
                    
                    if ventetid <= 20 and mulig_start < tidligste_start:
                        tidligste_start = mulig_start
                        bedste_idx = idx
                
                # 2. Hvis ingen passer i 20-min vinduet, tag den der trods alt er ledig tidligst
                if bedste_idx == -1:
                    for idx, row in mine.iterrows():
                        e = row['Elevid']
                        mulig_start = max(laerer_fri[laer], elev_fri[e])
                        if mulig_start < tidligste_start:
                            tidligste_start = mulig_start
                            bedste_idx = idx
                
                valgt = mine.loc[bedste_idx]
                st_tid = tidligste_start
                sl_tid = st_tid + timedelta(minutes=varighed_min)
                
                faerdig_plan.append({**valgt.to_dict(), 'Start_dt': st_tid, 'Slut_dt': sl_tid})
                laerer_fri[laer] = sl_tid
                elev_fri[valgt['Elevid']] = sl_tid
                resterende = resterende.drop(bedste_idx)

        res_df = pd.DataFrame(faerdig_plan)

        komprimering = strategi_params.get('komprimering', 0.0)
        if komprimering > 0:
            iterations = int(komprimering * 3)
            
            for _ in range(iterations):
                for laer in alle_laerere:
                    l_idx = res_df[res_df['L√¶rer'] == laer].sort_values('Start_dt', ascending=False).index
                    if len(l_idx) < 2: continue
                    
                    for i in range(len(l_idx) - 1):
                        idx_nu = l_idx[i]
                        idx_forrige = l_idx[i+1]
                        
                        ny_st = res_df.at[idx_nu, 'Start_dt'] - timedelta(minutes=varighed_min)
                        
                        e_id = res_df.at[idx_forrige, 'Elevid']
                        andre_e_aftaler = res_df[(res_df['Elevid'] == e_id) & (res_df.index != idx_forrige)]
                        
                        overlap = False
                        for _, aftale in andre_e_aftaler.iterrows():
                            if not (ny_st + timedelta(minutes=varighed_min) <= aftale['Start_dt'] or ny_st >= aftale['Slut_dt']):
                                overlap = True
                                break
                        
                        laast_tid_e = datetime.strptime(spec_tider_dict.get(e_id, "00:00"), "%H:%M") if e_id in spec_tider_dict else global_start
                        laast_tid_l = datetime.strptime(spec_tider_dict.get(laer, "00:00"), "%H:%M") if laer in spec_tider_dict else global_start
                        absolut_tidligst = max(global_start, laast_tid_e, laast_tid_l)

                        if not overlap and ny_st >= absolut_tidligst:
                            res_df.at[idx_forrige, 'Start_dt'] = ny_st
                            res_df.at[idx_forrige, 'Slut_dt'] = ny_st + timedelta(minutes=varighed_min)

        res_df['Start'] = res_df['Start_dt'].dt.strftime("%H:%M")
        
        lokaler = [l.strip() for l in lokaler_raw.split(',') if l.strip()]
        lokale_ledig_fra = {lok: global_start - timedelta(minutes=buffer_min) for lok in lokaler}
        laerer_til_lokale = {}
        laerer_blokke = res_df.groupby('L√¶rer').agg(Min_S=('Start_dt', 'min'), Max_S=('Slut_dt', 'max')).reset_index().sort_values('Min_S')
        
        for _, row in laerer_blokke.iterrows():
            valgt_lok = next((lok for lok in lokaler if row['Min_S'] >= lokale_ledig_fra[lok] + timedelta(minutes=buffer_min)), None)
            if valgt_lok:
                laerer_til_lokale[row['L√¶rer']] = valgt_lok
                lokale_ledig_fra[valgt_lok] = row['Max_S']
            else: laerer_til_lokale[row['L√¶rer']] = "‚ö†Ô∏è MANGLER LOKALE"

        res_df['Lokale'] = res_df['L√¶rer'].map(laerer_til_lokale)
        
        pauser = []
        for laer in alle_laerere:
            l_p = res_df[res_df['L√¶rer'] == laer].sort_values('Start_dt')
            for i in range(len(l_p)-1):
                pauser.append((l_p.iloc[i+1]['Start_dt'] - l_p.iloc[i]['Slut_dt']).total_seconds() / 60)
        avg_laerer_pause = sum(pauser) / len(pauser) if pauser else 0

        advarsler = []
        max_elev_ventetid = 0
        for e in alle_elever:
            e_p = res_df[res_df['Elevid'] == e].sort_values('Start_dt')
            for i in range(len(e_p)-1):
                gap = (e_p.iloc[i+1]['Start_dt'] - e_p.iloc[i]['Slut_dt']).total_seconds() / 60
                max_elev_ventetid = max(max_elev_ventetid, gap)
                if gap > 20:
                    advarsler.append(f"{e_p.iloc[0]['Elevnavn']} ({e}): {int(gap)} min")
        
        antal_elever_over_20 = len(advarsler)
        
        return res_df, advarsler, avg_laerer_pause, antal_elever_over_20, max_elev_ventetid
    except Exception as e: 
        return str(e), [], 999, 999, 999

def optimer_plan(df, start_str, lokaler_raw, spec_tider_dict, varighed_min, buffer_min):
    strategier = []
    
    # Strategier UDEN klasse-gruppering (for at sikre 0 elever over 20 min)
    strategier.append({
        'navn': 'Elev-fokus MAX (ingen gruppe)',
        'params': {'prioritering': 'elev_ventetid', 'komprimering': 0.0, 'klasse_gruppering': False}
    })
    
    strategier.append({
        'navn': 'Elev-fokus (ingen gruppe)',
        'params': {'prioritering': 'laaste_foerst', 'komprimering': 0.0, 'klasse_gruppering': False}
    })
    
    strategier.append({
        'navn': 'Kompakt l√¶rer (ingen gruppe)',
        'params': {'prioritering': 'belastning', 'komprimering': 1.0, 'klasse_gruppering': False}
    })
    
    for komp in [0.0, 0.2, 0.4, 0.6]:
        strategier.append({
            'navn': f'Balance {int(komp*100)}% komp (ingen gruppe)',
            'params': {'prioritering': 'belastning', 'komprimering': komp, 'klasse_gruppering': False}
        })
    
    # Elev-ventetid prioritering med lidt komprimering
    for komp in [0.1, 0.3, 0.5]:
        strategier.append({
            'navn': f'Elev-vent prioritet {int(komp*100)}% komp',
            'params': {'prioritering': 'elev_ventetid', 'komprimering': komp, 'klasse_gruppering': False}
        })
    
    # Strategier MED klasse-gruppering (bedre l√¶rer-kompakthed)
    strategier.append({
        'navn': 'Elev-fokus + klasse-gruppe',
        'params': {'prioritering': 'laaste_foerst', 'komprimering': 0.0, 'klasse_gruppering': True}
    })
    
    strategier.append({
        'navn': 'Elev-vent + klasse-gruppe',
        'params': {'prioritering': 'elev_ventetid', 'komprimering': 0.3, 'klasse_gruppering': True}
    })
    
    for komp in [0.3, 0.5, 0.7]:
        strategier.append({
            'navn': f'Balance {int(komp*100)}% + klasse-gruppe',
            'params': {'prioritering': 'belastning', 'komprimering': komp, 'klasse_gruppering': True}
        })
    
    # Strategier med offset
    for offset in [-20, -10, 0, 10]:
        if offset == 0:
            navn = 'Klasse-gruppe direkte'
        elif offset < 0:
            navn = f'Klasse-gruppe {abs(offset)}min f√∏r'
        else:
            navn = f'Klasse-gruppe {offset}min efter'
        strategier.append({
            'navn': navn,
            'params': {'prioritering': 'belastning', 'komprimering': 0.5, 'klasse_gruppering': True, 'klasse_offset': offset}
        })
    
    resultater = []
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    for idx, strat in enumerate(strategier):
        status_text.text(f"Tester strategi {idx+1}/{len(strategier)}: {strat['navn']}...")
        res_df, adv, avg_pause, antal_over_20, max_vent = beregn_plan_med_strategi(
            df, start_str, lokaler_raw, spec_tider_dict, varighed_min, buffer_min, strat['params']
        )
        
        if not isinstance(res_df, str):
            resultater.append({
                'strategi': strat['navn'],
                'df': res_df,
                'advarsler': adv,
                'avg_laerer_pause': avg_pause,
                'antal_elever_over_20': antal_over_20,
                'max_elev_ventetid': max_vent,
                'score': antal_over_20 * 1000 + avg_pause
            })
        
        progress_bar.progress((idx + 1) / len(strategier))
    
    status_text.empty()
    progress_bar.empty()
    
    valid_results = [r for r in resultater if r['antal_elever_over_20'] == 0]
    
    if not valid_results:
        valid_results = sorted(resultater, key=lambda x: (x['antal_elever_over_20'], x['avg_laerer_pause']))
    else:
        valid_results = sorted(valid_results, key=lambda x: x['avg_laerer_pause'])
    
    return valid_results[0], resultater

def generate_excel_elev(df):
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        for k in sorted(df['Klasse'].unique()):
            df_k = df[df['Klasse'] == k]
            p = df_k.pivot_table(index='Elevnavn', columns=['L√¶rer', 'Lokale'], values='Start', aggfunc='first').fillna("")
            if isinstance(p.columns, pd.MultiIndex): p.columns = [f"{l} ({loc})" for l, loc in p.columns]
            p.to_excel(writer, sheet_name=f'Klasse {k}')
    return output.getvalue()

def generate_excel_laerer(df):
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        adm = df.pivot_table(index='Start', columns=['Lokale', 'L√¶rer'], values='Elevid', aggfunc='first').fillna("")
        if isinstance(adm.columns, pd.MultiIndex): adm.columns = [f"{lok}: {l}" for lok, l in adm.columns]
        adm.to_excel(writer, sheet_name="ADMIN_SAMLET_PLAN")
        for laer in sorted(df['L√¶rer'].unique()):
            df_l = df[df['L√¶rer'] == laer].sort_values('Start_dt')
            sh = str(laer)[:31].translate({ord(c): None for c in '[]*?/:\\\\'})
            df_l[['Start', 'Elevnavn', 'Elevid', 'Klasse']].to_excel(writer, sheet_name=sh, index=False, startrow=2)
            ws = writer.sheets[sh]
            ws.write(0, 0, f"L√¶rer: {laer}"); ws.write(1, 0, f"Lokale: {df_l['Lokale'].iloc[0]}")
    return output.getvalue()

uploaded_file = st.file_uploader("Upload Excel med de korrekte kolonner", type=["xlsx"])
if uploaded_file:
    df_in = pd.read_excel(uploaded_file)
    if all(col in df_in.columns for col in ['Elevnavn', 'Elevid', '√ònsker']):
        bedste, alle_resultater = optimer_plan(df_in, start_tid_input, lokale_str, parse_tider(specifikke_tider_raw), varighed, lokale_buffer)
        
        res = bedste['df']
        adv = bedste['advarsler']
        avg_p = bedste['avg_laerer_pause']
        
        st.success(f"‚úÖ F√¶rdig! Bedste strategi: **{bedste['strategi']}**")
        st.success(f"Sidste samtale kl. {res.sort_values('Slut_dt').iloc[-1]['Slut_dt'].strftime('%H:%M')}")
        
        col1, col2, col3 = st.columns(3)
        col1.metric("üìä L√¶rerventetid (gennemsnit)", f"{avg_p:.1f} min")
        col2.metric("üë• Elever over 20 min ventetid", bedste['antal_elever_over_20'])
        col3.metric("‚è±Ô∏è Max elevventetid", f"{bedste['max_elev_ventetid']:.0f} min")
        
        if any(res['Lokale'] == "‚ö†Ô∏è MANGLER LOKALE"): st.error("‚ö†Ô∏è LOKALEMANGEL!")
        
        if adv:
            with st.expander("‚ö†Ô∏è Ventetider over 20 minutter"):
                for a in adv: st.write(f"- {a}")
        
        with st.expander("üìä Se alle testede strategier"):
            compare_df = pd.DataFrame([{
                'Strategi': r['strategi'],
                'Elever >20min': r['antal_elever_over_20'],
                'Max elevventetid': f"{r['max_elev_ventetid']:.0f} min",
                'Gennemsnitlig l√¶rerventetid': f"{r['avg_laerer_pause']:.1f} min"
            } for r in sorted(alle_resultater, key=lambda x: (x['antal_elever_over_20'], x['avg_laerer_pause']))])
            st.dataframe(compare_df, use_container_width=True)
        
        st.markdown("### Download resultater")
        c1, c2 = st.columns(2)
        c1.download_button("üì• Hent Elevoversigt", data=generate_excel_elev(res), file_name="Elevoversigt.xlsx")
        c2.download_button("üì• Hent L√¶reroversigt", data=generate_excel_laerer(res), file_name="Laereroversigt.xlsx")
    else:
        st.error("Filen skal indeholde: 'Elevnavn', 'Elevid', '√ònsker'.")
`
        },
      });
    </script>
  </body>
</html>
