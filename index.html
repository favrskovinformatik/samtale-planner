<!DOCTYPE html> 
<html> 
  <head> 
    <meta charset="UTF-8" /> 
    <meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /> 
    <title>Samtaleplanl√¶gger - Brute Force 100</title> 
    <script src="https://cdn.jsdelivr.net/gh/gzuidhof/coi-serviceworker@latest/coi-serviceworker.min.js"></script> 
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.css" /> 
  </head> 
  <body> 
    <div id="root"></div> 
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.js"></script> 
    <script> 
      stlite.mount({ 
        requirements: ["pandas", "openpyxl", "xlsxwriter"], 
        files: { 
          "streamlit_app.py": ` 
import streamlit as st 
import pandas as pd 
from datetime import datetime, timedelta 
import io 
import random

st.set_page_config(page_title="Samtaleplanl√¶gger", layout="wide", page_icon="üóìÔ∏è") 

# --- UI STYLING --- 
st.markdown(""" 
<style> 
    [data-testid="stSidebar"] { min-width: 450px !important; } 
    .stTextInput label, .stTextArea label, .stNumberInput label { font-weight: bold; } 
</style> 
""", unsafe_allow_html=True) 

st.title("üóìÔ∏è Samtaleplanl√¶gger") 

# --- INSTRUKTION OG EKSEMPEL --- 
st.info("### 1. Forbered din Excel-fil") 
st.markdown("""
S√∏rg for at dit regneark har pr√¶cis disse tre kolonneoverskrifter. Programmet k√∏rer nu automatisk **100 simulationer** for at finde den bedste plan.
""") 

example_data = { 
    "Elevnavn": ["Jonas Petersen"], 
    "Elevid": ["1x 07"], 
    "√ònsker": ["AG samfundsfag, SR, FH biologi, FH idr√¶t, GU"] 
} 
st.table(pd.DataFrame(example_data)) 

# --- SIDEBAR --- 
st.sidebar.header("1. Indstillinger") 
start_tid_input = st.sidebar.text_input("Starttidspunkt (tt.mm)", value="17.00") 
varighed = st.sidebar.number_input("Varighed (min)", value=10, step=5) 

st.sidebar.markdown("---") 
st.sidebar.header("2. Lokaler & Logistik") 
lokale_buffer = st.sidebar.number_input("Pause ved l√¶rerskift i lokale (min)", value=10, step=5) 
default_lokaler = "101, 409, 308, 309, 310, 312, 313, 315, 317, 508, 509, 510, 511, 513, 320, 321, 322, 323, 324, 210, 211, 213, 215, 216, 217, 218, 219, 220, M√∏de 1, M√∏de 2, M√∏de 3, M√∏de 4, M√∏de 5" 
lokale_str = st.sidebar.text_area("Lokaler (komma-separeret)", value=default_lokaler) 

st.sidebar.markdown("---") 
st.sidebar.header("3. Specifikke √∏nsker") 
specifikke_tider_raw = st.sidebar.text_area("Vejledninger for specifikke l√¶rere og elever planl√¶gges fra dette tidspunkt (Format: ID=tt.mm)", placeholder="AB=17.30\\n1q 18=17.00") 

# --- LOGIK --- 

def single_run(df_opgaver, global_start, spec_tider_dict, varighed_min, randomness=0.2):
    alle_l√¶rere = df_opgaver['L√¶rer'].unique().tolist()
    alle_elever = df_opgaver['Elevid'].unique().tolist()
    
    l√¶rer_fri = {l: global_start for l in alle_l√¶rere}
    elev_fri = {e: global_start for e in alle_elever}
    
    for k, v in spec_tider_dict.items():
        try:
            t = datetime.strptime(v, "%H:%M")
            if k in l√¶rer_fri: l√¶rer_fri[k] = t
            if k in elev_fri: elev_fri[k] = t
        except: pass

    plan = []
    resterende = df_opgaver.copy()
    
    # Pr√∏v at tildele opgaver
    while not resterende.empty:
        # V√¶lg l√¶rer (st√∏rst belastning f√∏rst, men med lidt st√∏j for at finde nye l√∏sninger)
        counts = resterende['L√¶rer'].value_counts()
        l√¶rere_sorteret = counts.index.tolist()
        
        # Introducer tilf√¶ldighed i l√¶rer-valg for at udforske l√∏sningsrummet
        if random.random() < randomness:
            random.shuffle(l√¶rere_sorteret)
        
        valgt_l√¶r = l√¶rere_sorteret[0]
        mine = resterende[resterende['L√¶rer'] == valgt_l√¶r]
        
        bedste_idx = -1
        bedste_start = datetime.max
        
        # Find bedste elev for denne l√¶rer
        # Vi prioriterer elever, der giver 0 ventetid, eller holder sig under 20 min
        for idx, row in mine.iterrows():
            e = row['Elevid']
            mulig_start = max(l√¶rer_fri[valgt_l√¶r], elev_fri[e])
            ventetid = (mulig_start - elev_fri[e]).total_seconds() / 60
            
            # Score-funktion: Priorit√©r tidlig start, men straf ventetid over 20 min voldsomt
            straf = 0
            if ventetid > 20: straf = 5000 
            elif ventetid > 0: straf = ventetid * 5
            
            current_score = mulig_start.timestamp() + straf
            
            if current_score < bedste_start.timestamp():
                bedste_start = mulig_start
                bedste_idx = idx
        
        valgt = mine.loc[bedste_idx]
        res_item = {
            **valgt.to_dict(), 
            'Start_dt': bedste_start, 
            'Slut_dt': bedste_start + timedelta(minutes=varighed_min)
        }
        plan.append(res_item)
        
        l√¶rer_fri[valgt_l√¶r] = res_item['Slut_dt']
        elev_fri[valgt['Elevid']] = res_item['Slut_dt']
        resterende = resterende.drop(bedste_idx)
        
    return pd.DataFrame(plan)

def optimer_plan(df, start_str, spec_tider, varighed_min, buffer_min, lokaler_raw):
    global_start = datetime.strptime(start_str.replace('.', ':'), "%H:%M")
    df = df.dropna(subset=['Elevnavn', 'Elevid', '√ònsker'])
    df['Elevid'] = df['Elevid'].astype(str).str.strip()
    df['Klasse'] = df['Elevid'].str[:2]
    
    opgaver_liste = []
    for _, row in df.iterrows():
        √∏nsker = [x.strip() for x in str(row['√ònsker']).split(',') if x.strip()]
        for item in √∏nsker:
            l√¶r = item.split()[0]
            opgaver_liste.append({'Elevid': row['Elevid'], 'Elevnavn': row['Elevnavn'], 'L√¶rer': l√¶r, 'Klasse': row['Klasse']})
    
    df_opgaver = pd.DataFrame(opgaver_liste)
    
    best_df = None
    best_score = float('inf')
    historik = []

    # Fast 100 iterationer
    for i in range(100):
        # √òg graden af tilf√¶ldighed gradvist
        r_factor = 0.1 + (i / 200) 
        current_df = single_run(df_opgaver, global_start, spec_tider, varighed_min, randomness=r_factor)
        
        # Beregn kvalitet
        elev_fejl = 0
        samlet_pause = 0
        for e in current_df['Elevid'].unique():
            e_p = current_df[current_df['Elevid'] == e].sort_values('Start_dt')
            for j in range(len(e_p)-1):
                gap = (e_p.iloc[j+1]['Start_dt'] - e_p.iloc[j]['Slut_dt']).total_seconds() / 60
                if gap > 20: elev_fejl += 1
        
        for l in current_df['L√¶rer'].unique():
            l_p = current_df[current_df['L√¶rer'] == l].sort_values('Start_dt')
            for j in range(len(l_p)-1):
                samlet_pause += (l_p.iloc[j+1]['Start_dt'] - l_p.iloc[j]['Slut_dt']).total_seconds() / 60
        
        # Score: Elev-fejl er f√∏rsteprioritet (v√¶gt 1 million), derefter samlet pause for l√¶rere
        score = (elev_fejl * 1000000) + samlet_pause
        historik.append({'Iteration': i+1, 'Elev-fejl': elev_fejl, 'L√¶rer-pause': samlet_pause})

        if score < best_score:
            best_score = score
            best_df = current_df.copy()

    # Tildel lokaler til vinderen
    lokaler = [l.strip() for l in lokaler_raw.split(',') if l.strip()]
    lokale_ledig = {lok: global_start - timedelta(minutes=buffer_min) for lok in lokaler}
    l_til_lok = {}
    l_blokke = best_df.groupby('L√¶rer').agg(S=('Start_dt', 'min'), E=('Slut_dt', 'max')).sort_values('S')
    
    for l√¶r, row in l_blokke.iterrows():
        valgt_lok = next((lk for lk in lokaler if row['S'] >= lokale_ledig[lk] + timedelta(minutes=buffer_min)), None)
        if valgt_lok:
            l_til_lok[l√¶r] = valgt_lok
            lokale_ledig[valgt_lok] = row['E']
        else:
            l_til_lok[l√¶r] = "‚ö†Ô∏è MANGLER LOKALE"

    best_df['Lokale'] = best_df['L√¶rer'].map(l_til_lok)
    best_df['Start'] = best_df['Start_dt'].dt.strftime("%H:%M")
    
    return best_df, historik

# --- EXCEL FUNKTIONER --- 
def generate_excel_elev(df): 
    output = io.BytesIO() 
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer: 
        for k in sorted(df['Klasse'].unique()): 
            df_k = df[df['Klasse'] == k] 
            p = df_k.pivot_table(index='Elevnavn', columns=['L√¶rer', 'Lokale'], values='Start', aggfunc='first').fillna("") 
            if isinstance(p.columns, pd.MultiIndex): p.columns = [f"{l} ({loc})" for l, loc in p.columns] 
            p.to_excel(writer, sheet_name=f'Klasse {k}') 
    return output.getvalue() 

def generate_excel_laerer(df): 
    output = io.BytesIO() 
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer: 
        for l√¶r in sorted(df['L√¶rer'].unique()): 
            df_l = df[df['L√¶rer'] == l√¶r].sort_values('Start_dt') 
            sh = str(l√¶r)[:31].translate({ord(c): None for c in '[]*?/:\\\\'}) 
            df_l[['Start', 'Elevnavn', 'Elevid', 'Klasse']].to_excel(writer, sheet_name=sh, index=False, startrow=2) 
            ws = writer.sheets[sh] 
            ws.write(0, 0, f"L√¶rer: {l√¶r}"); ws.write(1, 0, f"Lokale: {df_l['Lokale'].iloc[0]}") 
    return output.getvalue() 

# --- APP FLOW --- 
uploaded_file = st.file_uploader("Upload Excel med de korrekte kolonner", type=["xlsx"]) 
if uploaded_file: 
    df_in = pd.read_excel(uploaded_file) 
    if all(col in df_in.columns for col in ['Elevnavn', 'Elevid', '√ònsker']): 
        st.info("‚ö° Optimerer planen via 100 simulationer. Vent et √∏jeblik...")
        
        spec_tider = {}
        if specifikke_tider_raw:
            for line in specifikke_tider_raw.split('\\n'):
                if '=' in line:
                    p = line.split('=')
                    spec_tider[p[0].strip()] = p[1].strip().replace('.', ':')

        res, hist = optimer_plan(df_in, start_tid_input, spec_tider, varighed, lokale_buffer, lokale_str)
        
        st.success(f"F√¶rdig! Sidste samtale kl. {res['Slut_dt'].max().strftime('%H:%M')}") 
        
        # Vis resultater pr√¶cis som v1
        avg_pause = sum(h['L√¶rer-pause'] for h in hist) / (len(hist) * len(res['L√¶rer'].unique()))
        st.write(f"üìä **Optimering gennemf√∏rt.** Bedste udgave fundet.")
        
        if any(res['Lokale'] == "‚ö†Ô∏è MANGLER LOKALE"): st.error("‚ö†Ô∏è LOKALEMANGEL!") 
        
        # Ventetidsadvarsler
        advarsler = []
        for e in res['Elevid'].unique():
            e_p = res[res['Elevid'] == e].sort_values('Start_dt')
            for i in range(len(e_p)-1):
                gap = (e_p.iloc[i+1]['Start_dt'] - e_p.iloc[i]['Slut_dt']).total_seconds() / 60
                if gap > 20: advarsler.append(f"{e_p.iloc[0]['Elevnavn']} ({e}): {int(gap)} min")

        if advarsler: 
            with st.expander("‚ö†Ô∏è Ventetider over 20 minutter"): 
                for a in advarsler: st.write(f"- {a}") 
        
        st.markdown("### Simulationsoversigt")
        st.line_chart(pd.DataFrame(hist).set_index('Iteration'))

        st.markdown("### Download resultater") 
        c1, c2 = st.columns(2) 
        c1.download_button("üì• Hent Elevoversigt", data=generate_excel_elev(res), file_name="Elevoversigt.xlsx") 
        c2.download_button("üì• Hent L√¶reroversigt", data=generate_excel_laerer(res), file_name="Laereroversigt.xlsx") 
` 
        }, 
      }); 
    </script> 
  </body> 
</html>
