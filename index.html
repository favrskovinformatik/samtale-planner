<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>Samtaleplanl√¶gger</title>
    <script src="https://cdn.jsdelivr.net/gh/gzuidhof/coi-serviceworker@latest/coi-serviceworker.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.css" />
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.js"></script>
    <script>
      stlite.mount({
        requirements: ["pandas", "openpyxl", "xlsxwriter"],
        files: {
          "streamlit_app.py": `
import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
import io

st.set_page_config(page_title="Samtaleplanl√¶gger", layout="wide", page_icon="üóìÔ∏è")

# --- UI STYLING (DET ORIGINALE LAYOUT) ---
st.markdown("""
<style>
    [data-testid="stSidebar"] { min-width: 450px !important; }
    .stTextInput label, .stTextArea label, .stNumberInput label { font-weight: bold; }
    .example-table { margin-bottom: 20px; border-collapse: collapse; width: 100%; }
    .example-table td, .example-table th { border: 1px solid #ddd; padding: 8px; font-size: 0.9em; }
    .example-table th { background-color: #f2f2f2; text-align: left; }
</style>
""", unsafe_allow_html=True)

st.title("üóìÔ∏è Samtaleplanl√¶gger")

# --- INSTRUKTION OG EKSEMPEL (GENDANNET) ---
st.info("### 1. Forbered din Excel-fil")
st.markdown("""
S√∏rg for at dit regneark har pr√¶cis disse tre kolonneoverskrifter. Her er et eksempel:
""")

example_data = {
    "Elevnavn": ["Jonas Petersen"],
    "Elevid": ["1x 07"],
    "√ònsker": ["AG samfundsfag, SR, FH biologi"]
}
st.table(pd.DataFrame(example_data))

# --- SIDEBAR ---
st.sidebar.header("1. Indstillinger")
start_tid_input = st.sidebar.text_input("Starttidspunkt (tt.mm)", value="17.00")
varighed = st.sidebar.number_input("Varighed (min)", value=10, step=5)

st.sidebar.markdown("---")
st.sidebar.header("2. Lokaler & Logistik")
lokale_buffer = st.sidebar.number_input("Pause ved l√¶rerskift i lokale (min)", value=10, step=5)
default_lokaler = "101, 409, 308, 309, 310, 312, 313, 315, 317, 508, 509, 510, 511, 513, 320, 321, 322, 323, 324, 210, 211, 213, 215, 216, 217, 218, 219, 220, M√∏de 1, M√∏de 2, M√∏de 3, M√∏de 4, M√∏de 5"
lokale_str = st.sidebar.text_area("Lokaler (komma-separeret)", value=default_lokaler)

st.sidebar.markdown("---")
st.sidebar.header("3. Specifikke √∏nsker")
specifikke_tider_raw = st.sidebar.text_area("Vejledninger (Format: ID=tt.mm)", placeholder="1u 05=19.30\\nLE=17.00")

# --- LOGIK: BALANCERET ENGINE ---
def parse_tider(text_input):
    l√•ste_tider = {}
    if not text_input: return l√•ste_tider
    for line in text_input.split('\\n'):
        if '=' in line:
            parts = line.split('=')
            key = parts[0].strip()
            time_val = parts[1].strip().replace('.', ':')
            l√•ste_tider[key] = time_val
    return l√•ste_tider

def beregn_plan(df, start_str, lokaler_raw, spec_tider_dict, varighed_min, buffer_min):
    try:
        global_start = datetime.strptime(start_str.replace('.', ':'), "%H:%M")
        df = df.dropna(subset=['Elevnavn', 'Elevid', '√ònsker'])
        df['Elevid'] = df['Elevid'].astype(str).str.strip()
        df['Klasse'] = df['Elevid'].str[:2]
        
        opgaver = []
        for _, row in df.iterrows():
            √∏nsker = [x.strip() for x in str(row['√ònsker']).split(',') if x.strip()]
            for item in √∏nsker:
                parts = item.split()
                if parts and parts[0].upper() != "UKENDT":
                    opgaver.append({'Elevid': row['Elevid'], 'Elevnavn': row['Elevnavn'], 'L√¶rer': parts[0], 'Klasse': row['Klasse']})
        
        res_df = pd.DataFrame(opgaver)
        res_df['Start_dt'] = None
        res_df['Slut_dt'] = None
        
        alle_l√¶rere = res_df['L√¶rer'].unique()
        alle_elever = res_df['Elevid'].unique()
        l√¶rer_n√∏gle_tider = {l: global_start for l in alle_l√¶rere}
        elev_n√∏gle_tider = {e: [] for e in alle_elever}
        
        spec_tider = {}
        for k, v in spec_tider_dict.items():
            try: spec_tider[k] = datetime.strptime(v, "%H:%M")
            except: pass

        resterende_indices = list(res_df.index)
        # Prioriter elever med flest samtaler for at undg√• at de bliver spredt
        resterende_indices.sort(key=lambda i: -len(res_df[res_df['Elevid'] == res_df.loc[i, 'Elevid']]))

        while resterende_indices:
            bedste_score = float('inf')
            bedste_idx = -1
            bedste_tid = None
            
            for idx in resterende_indices[:40]: # Tjek de n√¶ste 40 mulige
                l√¶r = res_df.loc[idx, 'L√¶rer']
                elev = res_df.loc[idx, 'Elevid']
                
                l√¶r_klar = max(l√¶rer_n√∏gle_tider[l√¶r], spec_tider.get(l√¶r, global_start))
                e_klar = max(global_start, spec_tider.get(elev, global_start))
                
                test_tid = max(l√¶r_klar, e_klar)
                
                # Undg√• overlap for elev
                find_tid = True
                while find_tid:
                    overlap = False
                    for st_e, sl_e in elev_n√∏gle_tider[elev]:
                        if not (test_tid + timedelta(minutes=varighed_min) <= st_e or test_tid >= sl_e):
                            overlap = True
                            test_tid = sl_e
                            break
                    if not overlap: find_tid = False
                
                # Score-beregning (Balance)
                l_gap = (test_tid - l√¶rer_n√∏gle_tider[l√¶r]).total_seconds() / 60
                e_gap = 0
                if elev_n√∏gle_tider[elev]:
                    afstande = [min(abs((test_tid - sl).total_seconds()/60), abs((st - (test_tid + timedelta(minutes=varighed_min))).total_seconds()/60)) for st, sl in elev_n√∏gle_tider[elev]]
                    e_gap = min(afstande)
                
                # Vi v√¶gter elevens ventetid h√∏jt (2.0) for at holde deres program samlet
                score = l_gap + (e_gap * 2.0)
                
                if score < bedste_score:
                    bedste_score = score
                    bedste_idx = idx
                    bedste_tid = test_tid
            
            res_df.at[bedste_idx, 'Start_dt'] = bedste_tid
            res_df.at[bedste_idx, 'Slut_dt'] = bedste_tid + timedelta(minutes=varighed_min)
            l√¶rer_n√∏gle_tider[res_df.loc[bedste_idx, 'L√¶rer']] = res_df.loc[bedste_idx, 'Slut_dt']
            elev_n√∏gle_tider[res_df.loc[bedste_idx, 'Elevid']].append((bedste_tid, bedste_tid + timedelta(minutes=varighed_min)))
            resterende_indices.remove(bedste_idx)

        res_df['Start'] = res_df['Start_dt'].dt.strftime("%H:%M")
        
        # LOKALER
        lokaler = [l.strip() for l in lokaler_raw.split(',') if l.strip()]
        lokale_ledig_fra = {lok: global_start - timedelta(minutes=buffer_min) for lok in lokaler}
        l√¶rer_til_lokale = {}
        l√¶rer_blokke = res_df.groupby('L√¶rer').agg(Min_S=('Start_dt', 'min'), Max_S=('Slut_dt', 'max')).reset_index().sort_values('Min_S')
        for _, row in l√¶rer_blokke.iterrows():
            valgt_lok = next((lok for lok in lokaler if row['Min_S'] >= lokale_ledig_fra[lok] + timedelta(minutes=buffer_min)), None)
            if valgt_lok:
                l√¶rer_til_lokale[row['L√¶rer']] = valgt_lok
                lokale_ledig_fra[valgt_lok] = row['Max_S']
            else: l√¶rer_til_lokale[row['L√¶rer']] = "‚ö†Ô∏è MANGLER LOKALE"

        res_df['Lokale'] = res_df['L√¶rer'].map(l√¶rer_til_lokale)
        
        # Statistik
        pauser_l = []
        for l√¶r in alle_l√¶rere:
            l_p = res_df[res_df['L√¶rer'] == l√¶r].sort_values('Start_dt')
            for i in range(len(l_p)-1):
                pauser_l.append((l_p.iloc[i+1]['Start_dt'] - l_p.iloc[i]['Slut_dt']).total_seconds() / 60)
        avg_l = sum(pauser_l) / len(pauser_l) if pauser_l else 0

        advarsler = []
        for e in alle_elever:
            e_p = res_df[res_df['Elevid'] == e].sort_values('Start_dt')
            for i in range(len(e_p)-1):
                gap = (e_p.iloc[i+1]['Start_dt'] - e_p.iloc[i]['Slut_dt']).total_seconds() / 60
                if gap > 20: advarsler.append(f"{e_p.iloc[0]['Elevnavn']} ({e}): {int(gap)} min")
                    
        return res_df, advarsler, avg_l
    except Exception as e: return str(e), [], 0

# --- DOWNLOAD FUNKTIONER ---
def generate_excel_elev(df):
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        for k in sorted(df['Klasse'].unique()):
            df_k = df[df['Klasse'] == k]
            p = df_k.pivot_table(index='Elevnavn', columns=['L√¶rer', 'Lokale'], values='Start', aggfunc='first').fillna("")
            if isinstance(p.columns, pd.MultiIndex): p.columns = [f"{l} ({loc})" for l, loc in p.columns]
            p.to_excel(writer, sheet_name=f'Klasse {k}')
    return output.getvalue()

def generate_excel_laerer(df):
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        adm = df.pivot_table(index='Start', columns=['Lokale', 'L√¶rer'], values='Elevid', aggfunc='first').fillna("")
        if isinstance(adm.columns, pd.MultiIndex): adm.columns = [f"{lok}: {l}" for lok, l in adm.columns]
        adm.to_excel(writer, sheet_name="ADMIN_SAMLET_PLAN")
        for l√¶r in sorted(df['L√¶rer'].unique()):
            df_l = df[df['L√¶rer'] == l√¶r].sort_values('Start_dt')
            sh = str(l√¶r)[:31].translate({ord(c): None for c in '[]*?/:\\\\'})
            df_l[['Start', 'Elevnavn', 'Elevid', 'Klasse']].to_excel(writer, sheet_name=sh, index=False, startrow=2)
            ws = writer.sheets[sh]
            ws.write(0, 0, f"L√¶rer: {l√¶r}"); ws.write(1, 0, f"Lokale: {df_l['Lokale'].iloc[0]}")
    return output.getvalue()

uploaded_file = st.file_uploader("Upload din Excel-fil her", type=["xlsx"])
if uploaded_file:
    df_in = pd.read_excel(uploaded_file)
    if all(col in df_in.columns for col in ['Elevnavn', 'Elevid', '√ònsker']):
        res, adv, avg_l = beregn_plan(df_in, start_tid_input, lokale_str, parse_tider(specifikke_tider_raw), varighed, lokale_buffer)
        if isinstance(res, str): st.error(res)
        else:
            st.success(f"Planen er klar!")
            st.write(f"üìä **Gennemsnitlig ventetid for l√¶rere:** {avg_l:.1f} min.")
            if adv:
                with st.expander(f"‚ö†Ô∏è {len(adv)} elever har ventetid over 20 min"):
                    for a in adv: st.write(f"- {a}")
            c1, c2 = st.columns(2)
            c1.download_button("üì• Hent Elevoversigt", data=generate_excel_elev(res), file_name="Elevoversigt.xlsx")
            c2.download_button("üì• Hent L√¶reroversigt", data=generate_excel_laerer(res), file_name="Laereroversigt.xlsx")
    else: st.error("Excel-filen mangler de korrekte kolonner: 'Elevnavn', 'Elevid' og '√ònsker'")
`
        },
      });
    </script>
  </body>
</html>
