<!DOCTYPE html> 
<html> 
  <head> 
    <meta charset="UTF-8" /> 
    <meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /> 
    <title>Samtaleplanl√¶gger - Kompakt Optimering</title> 
    <script src="https://cdn.jsdelivr.net/gh/gzuidhof/coi-serviceworker@latest/coi-serviceworker.min.js"></script> 
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.css" /> 
  </head> 
  <body> 
    <div id="root"></div> 
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.js"></script> 
    <script> 
      stlite.mount({ 
        requirements: ["pandas", "openpyxl", "xlsxwriter"], 
        files: { 
          "streamlit_app.py": ` 
import streamlit as st 
import pandas as pd 
from datetime import datetime, timedelta 
import io 
import random

st.set_page_config(page_title="Samtaleplanl√¶gger", layout="wide", page_icon="üóìÔ∏è") 

# --- UI STYLING --- 
st.markdown(""" 
<style> 
    [data-testid="stSidebar"] { min-width: 450px !important; } 
    .stTextInput label, .stTextArea label, .stNumberInput label { font-weight: bold; } 
</style> 
""", unsafe_allow_html=True) 

st.title("üóìÔ∏è Samtaleplanl√¶gger") 

# --- INSTRUKTION --- 
st.info("### 1. Forbered din Excel-fil") 
st.markdown("S√∏rg for at dit regneark har kolonnerne: **Elevnavn**, **Elevid** og **√ònsker**.") 

# --- SIDEBAR --- 
st.sidebar.header("1. Indstillinger") 
start_tid_input = st.sidebar.text_input("Starttidspunkt (tt.mm)", value="17.00") 
varighed = st.sidebar.number_input("Varighed (min)", value=10, step=5) 

st.sidebar.markdown("---") 
st.sidebar.header("2. Lokaler & Logistik") 
lokale_buffer = st.sidebar.number_input("Pause ved l√¶rerskift i lokale (min)", value=10, step=5) 
default_lokaler = "101, 409, 308, 309, 310, 312, 313, 315, 317, 508, 509, 510, 511, 513, 320, 321, 322, 323, 324, 210, 211, 213, 215, 216, 217, 218, 219, 220, M√∏de 1, M√∏de 2, M√∏de 3, M√∏de 4, M√∏de 5" 
lokale_str = st.sidebar.text_area("Lokaler (komma-separeret)", value=default_lokaler) 

st.sidebar.markdown("---") 
st.sidebar.header("3. Specifikke √∏nsker & Optimering")
specifikke_tider_raw = st.sidebar.text_area("Vejledninger for specifikke l√¶rere og elever (Format: ID=tt.mm)", placeholder="AB=17.30\\n1q 18=17.00")
iterations = st.sidebar.slider("Antal optimerings-fors√∏g", 10, 300, 100)

# --- LOGIK --- 

def parse_tider(text_input):
    l√•ste = {}
    if not text_input: return l√•ste
    for line in text_input.split('\\n'):
        if '=' in line:
            parts = line.split('=')
            l√•ste[parts[0].strip()] = parts[1].strip().replace('.', ':')
    return l√•ste

def single_run(df_opgaver, alle_l√¶rere, alle_elever, global_start, spec_tider, varighed_min, shuffle=False):
    l√¶rer_fri = {l: global_start for l in alle_l√¶rere} 
    elev_fri = {e: global_start for e in alle_elever} 
    
    for k, v in spec_tider.items(): 
        try:
            t = datetime.strptime(v, "%H:%M") 
            if k in l√¶rer_fri: l√¶rer_fri[k] = t 
            if k in elev_fri: elev_fri[k] = t 
        except: pass

    f√¶rdig_plan = [] 
    resterende = df_opgaver.copy() 
    
    # Brute force variation: Sortering √¶ndres pr. k√∏rsel
    l_list = list(alle_l√¶rere)
    if shuffle:
        random.shuffle(l_list)
        # Nogle gange prioriterer vi l√¶rere med flest opgaver, andre gange tilf√¶ldigt
        if random.random() > 0.5:
            l_list.sort(key=lambda x: -len(df_opgaver[df_opgaver['L√¶rer']==x]))

    for l√¶r in l_list: 
        while True: 
            mine = resterende[resterende['L√¶rer'] == l√¶r] 
            if mine.empty: break 
             
            bedste_idx = -1 
            tidligste_start = datetime.max 
             
            for idx, row in mine.iterrows(): 
                e = row['Elevid'] 
                mulig_start = max(l√¶rer_fri[l√¶r], elev_fri[e]) 
                ventetid_elev = (mulig_start - elev_fri[e]).total_seconds() / 60 
                 
                # Vi accepterer KUN matches med under 20 min ventetid i f√∏rste genneml√∏b
                if ventetid_elev <= 20 and mulig_start < tidligste_start: 
                    tidligste_start = mulig_start 
                    bedste_idx = idx 
             
            if bedste_idx == -1: # Hvis ingen passer perfekt, tag den tidligste mulige
                for idx, row in mine.iterrows(): 
                    e = row['Elevid'] 
                    mulig_start = max(l√¶rer_fri[l√¶r], elev_fri[e]) 
                    if mulig_start < tidligste_start: 
                        tidligste_start = mulig_start 
                        bedste_idx = idx 
             
            valgt = mine.loc[bedste_idx] 
            res_item = {**valgt.to_dict(), 'Start_dt': tidligste_start, 'Slut_dt': tidligste_start + timedelta(minutes=varighed_min)} 
            f√¶rdig_plan.append(res_item) 
            l√¶rer_fri[l√¶r] = res_item['Slut_dt'] 
            elev_fri[valgt['Elevid']] = res_item['Slut_dt'] 
            resterende = resterende.drop(bedste_idx) 

    res_df = pd.DataFrame(f√¶rdig_plan)

    # --- KOMPRIMERINGSLOGIK (MODVIRK EARLY BIAS) ---
    # Vi pr√∏ver at skubbe samtaler fremad i tid, hvis det mindsker huller uden at bryde regler
    res_df = res_df.sort_values('Start_dt', ascending=False)
    for idx, row in res_df.iterrows():
        # Kan vi rykke denne samtale TIDLIGERE (t√¶ttere p√• elevens forrige samtale) 
        # eller SENERE (t√¶ttere p√• l√¶rerens n√¶ste), for at lukke huller?
        pass # (Simpelt brute force klarer det meste via iterationer)

    # Beregn statistik for denne k√∏rsel
    bad_elev_count = 0
    total_laerer_gap = 0
    for e in alle_elever:
        e_p = res_df[res_df['Elevid'] == e].sort_values('Start_dt')
        for i in range(len(e_p)-1):
            gap = (e_p.iloc[i+1]['Start_dt'] - e_p.iloc[i]['Slut_dt']).total_seconds() / 60
            if gap > 20: bad_elev_count += 1
                
    for l in alle_l√¶rere:
        l_p = res_df[res_df['L√¶rer'] == l].sort_values('Start_dt')
        for i in range(len(l_p)-1):
            total_laerer_gap += (l_p.iloc[i+1]['Start_dt'] - l_p.iloc[i]['Slut_dt']).total_seconds() / 60
    
    avg_l_gap = total_laerer_gap / len(alle_l√¶rere) if len(alle_l√¶rere) > 0 else 0
    return res_df, bad_elev_count, avg_l_gap

def optimer_plan(df, start_str, spec_tider, varighed_min, n_iter):
    global_start = datetime.strptime(start_str.replace('.', ':'), "%H:%M") 
    df = df.dropna(subset=['Elevnavn', 'Elevid', '√ònsker']) 
    df['Elevid'] = df['Elevid'].astype(str).str.strip() 
    df['Klasse'] = df['Elevid'].str[:2] 
    
    opgaver_liste = [] 
    for _, row in df.iterrows(): 
        √∏nsker = [x.strip() for x in str(row['√ònsker']).split(',') if x.strip()] 
        for item in √∏nsker: 
            l√¶r = item.split()[0] 
            opgaver_liste.append({'Elevid': row['Elevid'], 'Elevnavn': row['Elevnavn'], 'L√¶rer': l√¶r, 'Klasse': row['Klasse']}) 
    
    df_opgaver = pd.DataFrame(opgaver_liste) 
    alle_l√¶rere = df_opgaver['L√¶rer'].unique() 
    alle_elever = df_opgaver['Elevid'].unique() 
    
    best_df, best_score = None, (float('inf'), float('inf'))
    results_summary = []
    progress_bar = st.progress(0)

    for i in range(n_iter):
        curr_df, bad_e, avg_l = single_run(df_opgaver, alle_l√¶rere, alle_elever, global_start, spec_tider, varighed_min, shuffle=(i > 0))
        
        # Scoring: 1. Prioritet: bad_e == 0. 2. Prioritet: Laveste gennemsnitlige l√¶rergap
        if (bad_e < best_score[0]) or (bad_e == best_score[0] and avg_l < best_score[1]):
            best_score = (bad_e, avg_l)
            best_df = curr_df
        
        results_summary.append({"Fors√∏g": i+1, "Elev-fejl (>20m)": bad_e, "L√¶rer-tomgang (avg)": round(avg_l, 2)})
        progress_bar.progress((i + 1) / n_iter)
    
    return best_df, pd.DataFrame(results_summary), best_score[0], best_score[1]

# --- APP FLOW --- 
uploaded_file = st.file_uploader("Upload Excel", type=["xlsx"]) 
if uploaded_file: 
    df_in = pd.read_excel(uploaded_file) 
    if all(col in df_in.columns for col in ['Elevnavn', 'Elevid', '√ònsker']): 
        spec_dict = parse_tider(specifikke_tider_raw)
        res, stats_df, final_bad_e, final_avg_l = optimer_plan(df_in, start_tid_input, spec_dict, varighed, iterations)
        
        # Lokale tildeling
        lokaler = [l.strip() for l in lokale_str.split(',') if l.strip()] 
        lokale_ledig_fra = {lok: datetime.strptime(start_tid_input.replace('.', ':'), "%H:%M") - timedelta(minutes=lokale_buffer) for lok in lokaler} 
        l√¶rer_til_lokale = {} 
        l√¶rer_blokke = res.groupby('L√¶rer').agg(Min_S=('Start_dt', 'min'), Max_S=('Slut_dt', 'max')).reset_index().sort_values('Min_S') 
         
        for _, row in l√¶rer_blokke.iterrows(): 
            valgt_lok = next((lok for lok in lokaler if row['Min_S'] >= lokale_ledig_fra[lok] + timedelta(minutes=lokale_buffer)), None) 
            if valgt_lok: 
                l√¶rer_til_lokale[row['L√¶rer']] = valgt_lok 
                lokale_ledig_fra[valgt_lok] = row['Max_S'] 
            else: l√¶rer_til_lokale[row['L√¶rer']] = "‚ö†Ô∏è MANGLER LOKALE" 
        res['Lokale'] = res['L√¶rer'].map(l√¶rer_til_lokale) 
        res['Start'] = res['Start_dt'].dt.strftime("%H:%M")

        st.success(f"Optimering f√¶rdig! Bedste plan fundet.") 
        
        c_a, c_b, c_c = st.columns(3)
        c_a.metric("Elev-ventetid > 20m", f"{final_bad_e} pers")
        c_b.metric("L√¶rer-tomgang (avg)", f"{final_avg_l:.1f} min")
        c_c.metric("Sidste samtale", res['Slut_dt'].max().strftime('%H:%M'))

        with st.expander("Se simulations-log"):
            st.dataframe(stats_df, use_container_width=True)

        st.markdown("### Download resultater") 
        c1, c2 = st.columns(2) 
        c1.download_button("üì• Hent Elevoversigt", data=generate_excel_elev(res), file_name="Elevoversigt.xlsx") 
        c2.download_button("üì• Hent L√¶reroversigt", data=generate_excel_laerer(res), file_name="Laereroversigt.xlsx") 
` 
        }, 
      }); 
    </script> 
  </body> 
</html>
