<!DOCTYPE html> 
<html> 
  <head> 
    <meta charset="UTF-8" /> 
    <meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /> 
    <title>Samtaleplanl√¶gger</title> 
    <script src="https://cdn.jsdelivr.net/gh/gzuidhof/coi-serviceworker@latest/coi-serviceworker.min.js"></script> 
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.css" /> 
  </head> 
  <body> 
    <div id="root"></div> 
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.js"></script> 
    <script> 
      stlite.mount({ 
        requirements: ["pandas", "openpyxl", "xlsxwriter"], 
        files: { 
          "streamlit_app.py": ` 
import streamlit as st 
import pandas as pd 
from datetime import datetime, timedelta 
import io 

st.set_page_config(page_title="Samtaleplanl√¶gger", layout="wide", page_icon="üóìÔ∏è") 

# --- UI STYLING --- 
st.markdown(""" 
<style> 
    [data-testid="stSidebar"] { min-width: 450px !important; } 
    .stTextInput label, .stTextArea label, .stNumberInput label { font-weight: bold; } 
    .example-table { margin-bottom: 20px; border-collapse: collapse; width: 100%; } 
    .example-table td, .example-table th { border: 1px solid #ddd; padding: 8px; font-size: 0.9em; } 
    .example-table th { background-color: #f2f2f2; text-align: left; } 
</style> 
""", unsafe_allow_html=True) 

st.title("üóìÔ∏è Samtaleplanl√¶gger") 

# --- INSTRUKTION OG EKSEMPEL --- 
st.info("### 1. Forbered din Excel-fil") 
st.markdown(""" 
S√∏rg for at dit regneark har pr√¶cis disse tre kolonneoverskrifter. Her er et eksempel p√•, hvordan en r√¶kke skal se ud: 
""") 

example_data = { 
    "Elevnavn": ["Jonas Petersen"], 
    "Elevid": ["1x 07"], 
    "√ònsker": ["AG samfundsfag, SR, FH biologi, FH idr√¶t, GU"] 
} 
st.table(pd.DataFrame(example_data)) 

st.markdown(""" 
Regnearket kan godt have flere kolonner, men de bliver ignoreret. Det samme g√¶lder fagene - det er kun initialerne, som programmet bruger. 
""") 

# --- SIDEBAR --- 
st.sidebar.header("1. Indstillinger") 
start_tid_input = st.sidebar.text_input("Starttidspunkt (tt.mm)", value="17.00") 
varighed = st.sidebar.number_input("Varighed (min)", value=10, step=5) 

st.sidebar.markdown("---") 
st.sidebar.header("2. Lokaler & Logistik") 
lokale_buffer = st.sidebar.number_input("Pause ved l√¶rerskift i lokale (min)", value=10, step=5) 
default_lokaler = "101, 409, 308, 309, 310, 312, 313, 315, 317, 508, 509, 510, 511, 513, 320, 321, 322, 323, 324, 210, 211, 213, 215, 216, 217, 218, 219, 220, M√∏de 1, M√∏de 2, M√∏de 3, M√∏de 4, M√∏de 5" 
lokale_str = st.sidebar.text_area("Lokaler (komma-separeret)", value=default_lokaler) 

st.sidebar.markdown("---") 
st.sidebar.header("3. Specifikke √∏nsker") 
specifikke_tider_raw = st.sidebar.text_area("Vejledninger for specifikke l√¶rere og elever planl√¶gges fra dette tidspunkt (Format: ID=tt.mm)", placeholder="AB=17.30\\\\n1q 18=17.00") 

# --- LOGIK --- 

def parse_tider(text_input): 
    l√•ste_tider = {} 
    if not text_input: return l√•ste_tider 
    for line in text_input.split('\\n'): 
        if '=' in line: 
            parts = line.split('=') 
            key = parts[0].strip() 
            time_val = parts[1].strip().replace('.', ':') 
            l√•ste_tider[key] = time_val 
    return l√•ste_tider 

def beregn_plan(df, start_str, lokaler_raw, spec_tider_dict, varighed_min, buffer_min): 
    try: 
        global_start = datetime.strptime(start_str.replace('.', ':'), "%H:%M") 
        df = df.dropna(subset=['Elevnavn', 'Elevid', '√ònsker']) 
        df['Elevid'] = df['Elevid'].astype(str).str.strip() 
        df['Klasse'] = df['Elevid'].str[:2] 
        
        # Opbyg data-struktur
        elever_data = {}
        for _, row in df.iterrows():
            wishes = [x.strip().split()[0] for x in str(row['√ònsker']).split(',') if x.strip()]
            elever_data[row['Elevid']] = {
                'navn': row['Elevnavn'],
                'klasse': row['Klasse'],
                'wishes': wishes
            }
        
        alle_l√¶rere = list(set([w for s in elever_data.values() for w in s['wishes']]))
        l√¶rer_fri = {l: global_start for l in alle_l√¶rere}
        
        # Parse specifikke tider
        spec_tider = {}
        for k, v in spec_tider_dict.items():
            try: spec_tider[k] = datetime.strptime(v, "%H:%M")
            except: pass

        # Prioritering: Elever med flest √∏nsker f√∏rst (de er sv√¶rest at f√• plads til)
        sorted_e_ids = sorted(elever_data.keys(), key=lambda x: (-len(elever_data[x]['wishes']), x))
        
        f√¶rdig_plan = []
        
        for e_id in sorted_e_ids:
            e_info = elever_data[e_id]
            wishes = e_info['wishes']
            
            # Find f√∏rste ledige vindue for ELEV-K√ÜDEN (Brute force search)
            found = False
            search_start = max(global_start, spec_tider.get(e_id, global_start))
            
            while not found:
                temp_bookings = []
                current_e_time = search_start
                possible = True
                
                # Sorter wishes for denne elev: tag den mest belastede l√¶rer f√∏rst i k√¶den
                # (Dette er en vigtig heuristik for at undg√• at blokere senere)
                wishes_sorted = sorted(wishes, key=lambda x: len([e for e in elever_data.values() if x in e['wishes']]), reverse=True)
                
                for l√¶r in wishes_sorted:
                    l_start_tidligst = max(current_e_time, l√¶rer_fri[l√¶r], spec_tider.get(l√¶r, global_start))
                    
                    # Tjek om ventetiden er over 20 min (hvis ikke det er f√∏rste samtale)
                    if len(temp_bookings) > 0:
                        sidste_slut = max([b['Slut_dt'] for b in temp_bookings])
                        if (l_start_tidligst - sidste_slut).total_seconds() / 60 > 20:
                            possible = False
                            break
                    
                    temp_bookings.append({
                        'Elevid': e_id, 
                        'Elevnavn': e_info['navn'], 
                        'L√¶rer': l√¶r, 
                        'Klasse': e_info['klasse'],
                        'Start_dt': l_start_tidligst,
                        'Slut_dt': l_start_tidligst + timedelta(minutes=varighed_min)
                    })
                    # Eleven kan starte n√¶ste samtale umiddelbart efter
                    current_e_time = l_start_tidligst + timedelta(minutes=varighed_min)
                
                if possible:
                    # Book det!
                    for b in temp_bookings:
                        f√¶rdig_plan.append(b)
                        l√¶rer_fri[b['L√¶rer']] = b['Slut_dt']
                    found = True
                else:
                    # Pr√∏v at starte k√¶den 5 minutter senere
                    search_start += timedelta(minutes=5)
                    if search_start > global_start + timedelta(hours=6):
                        # Sikkerhedsventil
                        break

        res_df = pd.DataFrame(f√¶rdig_plan)
        res_df['Start'] = res_df['Start_dt'].dt.strftime("%H:%M")
        
        # Lokaler
        lokaler = [l.strip() for l in lokaler_raw.split(',') if l.strip()]
        lokale_ledig_fra = {lok: global_start - timedelta(minutes=buffer_min) for lok in lokaler}
        l√¶rer_til_lokale = {}
        l√¶rer_blokke = res_df.groupby('L√¶rer').agg(Min_S=('Start_dt', 'min'), Max_S=('Slut_dt', 'max')).reset_index().sort_values('Min_S')
        
        for _, row in l√¶rer_blokke.iterrows():
            valgt_lok = next((lok for lok in lokaler if row['Min_S'] >= lokale_ledig_fra[lok] + timedelta(minutes=buffer_min)), None)
            if valgt_lok:
                l√¶rer_til_lokale[row['L√¶rer']] = valgt_lok
                lokale_ledig_fra[valgt_lok] = row['Max_S']
            else: l√¶rer_til_lokale[row['L√¶rer']] = "‚ö†Ô∏è MANGLER LOKALE"

        res_df['Lokale'] = res_df['L√¶rer'].map(l√¶rer_til_lokale)
        
        # Statistik
        pauser = []
        for l√¶r in alle_l√¶rere:
            l_p = res_df[res_df['L√¶rer'] == l√¶r].sort_values('Start_dt')
            for i in range(len(l_p)-1):
                pauser.append((l_p.iloc[i+1]['Start_dt'] - l_p.iloc[i]['Slut_dt']).total_seconds() / 60)
        avg_p = sum(pauser) / len(pauser) if pauser else 0

        advarsler = []
        for e in sorted_e_ids:
            e_p = res_df[res_df['Elevid'] == e].sort_values('Start_dt')
            for i in range(len(e_p)-1):
                gap = (e_p.iloc[i+1]['Start_dt'] - e_p.iloc[i]['Slut_dt']).total_seconds() / 60
                if gap > 20: advarsler.append(f"{e_p.iloc[0]['Elevnavn']} ({e}): {int(gap)} min")
                    
        return res_df, advarsler, avg_p
    except Exception as e: return str(e), [], 0

# --- EXCEL FUNKTIONER (U√ÜNDRET) --- 
def generate_excel_elev(df): 
    output = io.BytesIO() 
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer: 
        for k in sorted(df['Klasse'].unique()): 
            df_k = df[df['Klasse'] == k] 
            p = df_k.pivot_table(index='Elevnavn', columns=['L√¶rer', 'Lokale'], values='Start', aggfunc='first').fillna("") 
            if isinstance(p.columns, pd.MultiIndex): p.columns = [f"{l} ({loc})" for l, loc in p.columns] 
            p.to_excel(writer, sheet_name=f'Klasse {k}') 
    return output.getvalue() 

def generate_excel_laerer(df): 
    output = io.BytesIO() 
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer: 
        adm = df.pivot_table(index='Start', columns=['Lokale', 'L√¶rer'], values='Elevid', aggfunc='first').fillna("") 
        if isinstance(adm.columns, pd.MultiIndex): adm.columns = [f"{lok}: {l}" for lok, l in adm.columns] 
        adm.to_excel(writer, sheet_name="ADMIN_SAMLET_PLAN") 
        for l√¶r in sorted(df['L√¶rer'].unique()): 
            df_l = df[df['L√¶rer'] == l√¶r].sort_values('Start_dt') 
            sh = str(l√¶r)[:31].translate({ord(c): None for c in '[]*?/:\\\\'}) 
            df_l[['Start', 'Elevnavn', 'Elevid', 'Klasse']].to_excel(writer, sheet_name=sh, index=False, startrow=2) 
            ws = writer.sheets[sh] 
            ws.write(0, 0, f"L√¶rer: {l√¶r}"); ws.write(1, 0, f"Lokale: {df_l['Lokale'].iloc[0]}") 
    return output.getvalue() 

# --- APP FLOW --- 
uploaded_file = st.file_uploader("Upload Excel med de korrekte kolonner", type=["xlsx"]) 
if uploaded_file: 
    df_in = pd.read_excel(uploaded_file) 
    if all(col in df_in.columns for col in ['Elevnavn', 'Elevid', '√ònsker']): 
        res, adv, avg_p = beregn_plan(df_in, start_tid_input, lokale_str, parse_tider(specifikke_tider_raw), varighed, lokale_buffer) 
        if isinstance(res, str): st.error(res) 
        else: 
            st.success(f"F√¶rdig! Sidste samtale kl. {res.sort_values('Slut_dt').iloc[-1]['Slut_dt'].strftime('%H:%M')}") 
            st.write(f"üìä **Gennemsnitlig ventetid for l√¶rere:** {avg_p:.1f} min.") 
            if any(res['Lokale'] == "‚ö†Ô∏è MANGLER LOKALE"): st.error("‚ö†Ô∏è LOKALEMANGEL!") 
            if adv: 
                with st.expander("‚ö†Ô∏è Ventetider over 20 minutter"): 
                    for a in adv: st.write(f"- {a}") 
            st.markdown("### Download resultater") 
            c1, c2 = st.columns(2) 
            c1.download_button("üì• Hent Elevoversigt", data=generate_excel_elev(res), file_name="Elevoversigt.xlsx") 
            c2.download_button("üì• Hent L√¶reroversigt", data=generate_excel_laerer(res), file_name="Laereroversigt.xlsx") 
` 
        }, 
      }); 
    </script> 
  </body> 
</html>
