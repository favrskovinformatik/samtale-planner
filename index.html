<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>Samtaleplanl√¶gger Pro</title>
    <script src="https://cdn.jsdelivr.net/gh/gzuidhof/coi-serviceworker@latest/coi-serviceworker.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.css" />
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.js"></script>
    <script>
      stlite.mount({
        requirements: ["pandas", "openpyxl", "xlsxwriter"],
        files: {
          "streamlit_app.py": `
import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
import io

# --- SIDE OPS√ÜTNING ---
st.set_page_config(page_title="Samtaleplanl√¶gger", layout="wide", page_icon="üóìÔ∏è")

st.markdown("""
<style>
    /* Forbedrer layout i sidebar s√• labels ikke kn√¶kker */
    [data-testid="stSidebar"] { min-width: 450px !important; }
    .stTextInput label, .stTextArea label { white-space: nowrap !important; font-weight: bold; }
    /* G√∏r tabeller p√¶nere */
    [data-testid="stDataFrameResizable"] { border: 1px solid #eee; }
</style>
""", unsafe_allow_html=True)

st.title("üóìÔ∏è Samtaleplanl√¶gger")
st.markdown("Denne app sikrer kompakte tidsplaner for elever og smart fordeling af lokaler med buffer-tid.")

# --- SIDEBAR: INDSTILLINGER ---
st.sidebar.header("1. Indstillinger")

col1, col2 = st.sidebar.columns(2)
with col1:
    start_tid_input = st.text_input("Starttidspunkt (tt:mm)", value="08:00")
with col2:
    varighed = st.number_input("Varighed (min)", value=10, step=5)

st.sidebar.markdown("---")
st.sidebar.header("2. Lokaler & Logistik")
lokale_buffer = st.sidebar.number_input("Pause ved l√¶rerskift i lokale (min)", value=10, step=5)
lokale_str = st.sidebar.text_area("Lokaler (komma-separeret)", 
    value="308, 309, 321, 510, 513", 
    help="Indtast lokalenumre. Systemet grupperer l√¶rere efter sektion (f√∏rste ciffer)."
)

st.sidebar.markdown("---")
st.sidebar.header("3. Specifikke √∏nsker")
st.sidebar.info("Her kan du l√•se starttider. Brug **Elevid** for elever og **Initialer** for l√¶rere.")
specifikke_tider_raw = st.sidebar.text_area(
    "L√•ste tider (Format: ID=tt:mm)",
    placeholder="AB=09:00\\n1a05=08:30",
    height=150
)

# --- HJ√ÜLPEFUNKTIONER ---

def parse_tider(text_input):
    """Omdanner tekstinput til dictionary"""
    l√•ste_tider = {}
    if not text_input: return l√•ste_tider
    for line in text_input.split('\\n'):
        if '=' in line:
            parts = line.split('=')
            key = parts[0].strip()
            time_val = parts[1].strip().replace('.', ':')
            l√•ste_tider[key] = time_val
    return l√•ste_tider

def get_template():
    """Genererer en tom Excel-skabelon"""
    df_temp = pd.DataFrame(columns=["Elevnavn", "Elevid", "√ònsker"])
    df_temp.loc[0] = ["Jens Jensen", "1a01", "AB, CD"]
    df_temp.loc[1] = ["Ulla Hansen", "1a02", "EF, AB"]
    
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df_temp.to_excel(writer, index=False, sheet_name='Input_Data')
    return output.getvalue()

def sorter_lokaler(lokaler_liste):
    """Sorterer lokaler smart (s√• 10 kommer efter 2)"""
    def convert(text): return int(text) if text.isdigit() else text
    return sorted(lokaler_liste, key=convert)

# --- HOVEDLOGIK ---

def beregn_plan(df, start_str, lokaler_raw, spec_tider_dict, varighed_min, buffer_min):
    try:
        start_dt = datetime.strptime(start_str.replace('.', ':'), "%H:%M")
        
        # 1. RENS DATA
        df['Elevid'] = df['Elevid'].astype(str).str.strip()
        df['Klasse'] = df['Elevid'].str[:2] # Antager de to f√∏rste tegn er klassen
        
        # Split '√ònsker' op i r√¶kker pr. samtale
        samtaler = []
        # Opt√¶l hvilke klasser hver l√¶rer har mest (til lokale-sektionering)
        l√¶rer_klasser = {} 
        
        for _, row in df.iterrows():
            √∏nsker = [x.strip() for x in str(row['√ònsker']).split(',') if x.strip()]
            for l√¶r in √∏nsker:
                samtaler.append({
                    'Elevnavn': row['Elevnavn'],
                    'Elevid': row['Elevid'],
                    'L√¶rer': l√¶r,
                    'Klasse': row['Klasse']
                })
                if l√¶r not in l√¶rer_klasser: l√¶rer_klasser[l√¶r] = []
                l√¶rer_klasser[l√¶r].append(row['Klasse'])
        
        df_samtaler = pd.DataFrame(samtaler)
        alle_l√¶rere = df_samtaler['L√¶rer'].unique()
        alle_elever = df_samtaler['Elevid'].unique()

        # Find "Hjemme-sektion" for hver l√¶rer (den klasse de har flest af)
        prim√¶r_klasse = {l: max(set(k), key=k.count) for l, k in l√¶rer_klasser.items()}

        # 2. PLANL√ÜG TIDER (Elev-kompakthed)
        # Vi holder styr p√• hvorn√•r l√¶rere og elever er ledige
        l√¶rer_fri = {l: start_dt for l in alle_l√¶rere}
        elev_fri = {e: start_dt for e in alle_elever}
        
        # Inds√¶t specifikke starttider
        for id_key, tid_str in spec_tider_dict.items():
            try:
                spec_dt = datetime.strptime(tid_str, "%H:%M")
                if id_key in l√¶rer_fri: l√¶rer_fri[id_key] = spec_dt
                if id_key in elev_fri: elev_fri[id_key] = spec_dt
            except:
                pass # Ignorer ugyldige tidsformater

        f√¶rdig_plan = []
        
        # Iterer gennem hver elev og planl√¶g deres samtaler back-to-back
        for elev_id in alle_elever:
            mine_samtaler = df_samtaler[df_samtaler['Elevid'] == elev_id]
            
            for _, r in mine_samtaler.iterrows():
                l√¶r = r['L√¶rer']
                
                # Tidligste start er n√•r b√•de elev og l√¶rer er fri
                start = max(l√¶rer_fri[l√¶r], elev_fri[elev_id])
                slut = start + timedelta(minutes=varighed_min)
                
                f√¶rdig_plan.append({
                    'Elevnavn': r['Elevnavn'],
                    'Elevid': elev_id,
                    'Klasse': r['Klasse'],
                    'L√¶rer': l√¶r,
                    'Start_dt': start,
                    'Slut_dt': slut
                })
                
                # Opdater ledighed
                l√¶rer_fri[l√¶r] = slut
                elev_fri[elev_id] = slut

        res_df = pd.DataFrame(f√¶rdig_plan)

        # 3. TILDEL LOKALER (L√¶rer-kontinuitet + Buffer + N√¶rhed)
        lokaler = sorter_lokaler([l.strip() for l in lokaler_raw.split(',') if l.strip()])
        
        # Vi skal vide hvorn√•r en l√¶rer starter f√∏rste samtale og slutter sidste
        l√¶rer_blokke = res_df.groupby('L√¶rer').agg(
            Min_Start=('Start_dt', 'min'),
            Max_Slut=('Slut_dt', 'max')
        ).reset_index()
        
        # Sorter l√¶rere: F√∏rst efter prim√¶r klasse (saml sektioner), s√• efter starttid
        l√¶rer_blokke['Prim√¶r_Klasse'] = l√¶rer_blokke['L√¶rer'].map(prim√¶r_klasse)
        l√¶rer_blokke = l√¶rer_blokke.sort_values(['Prim√¶r_Klasse', 'Min_Start'])
        
        # Hold styr p√• hvorn√•r hvert lokale er ledigt
        lokale_ledig_fra = {lok: start_dt - timedelta(minutes=buffer_min) for lok in lokaler}
        # (Vi tr√¶kker buffer fra start, s√• f√∏rste l√¶rer kan starte pr√¶cis kl. starttid)

        l√¶rer_til_lokale = {}
        
        for _, row in l√¶rer_blokke.iterrows():
            l√¶r = row['L√¶rer']
            start_blok = row['Min_Start']
            slut_blok = row['Max_Slut']
            
            valgt_lokale = None
            
            # Find f√∏rste ledige lokale, der overholder buffer-kravet
            for lok in lokaler:
                tidligst_mulig = lokale_ledig_fra[lok] + timedelta(minutes=buffer_min)
                
                # Hvis l√¶reren starter senere end (lokale_fri + buffer), s√• er det OK
                if start_blok >= tidligst_mulig:
                    valgt_lokale = lok
                    # Opdater lokalets ledighed til n√•r denne l√¶rer er f√¶rdig
                    lokale_ledig_fra[lok] = slut_blok 
                    break
            
            if valgt_lokale:
                l√¶rer_til_lokale[l√¶r] = valgt_lokale
            else:
                l√¶rer_til_lokale[l√¶r] = "MGL. LOKALE"

        # S√¶t lokaler og formater tider p√• hoved-dataframen
        res_df['Lokale'] = res_df['L√¶rer'].map(l√¶rer_til_lokale)
        res_df['Start'] = res_df['Start_dt'].dt.strftime("%H:%M")
        
        return res_df.sort_values(['Klasse', 'Elevnavn', 'Start_dt'])

    except Exception as e:
        return str(e)

# --- UI VISNING ---

col_upload, col_dl_temp = st.columns([3, 1])
with col_dl_temp:
    st.markdown("<br>", unsafe_allow_html=True) # Spacer
    st.download_button("üì• Hent Skabelon", data=get_template(), file_name="skabelon_samtaler.xlsx", help="Hent en tom Excel-fil med de korrekte kolonner.")

with col_upload:
    uploaded_file = st.file_uploader("Upload udfyldt Excel-fil", type=["xlsx"])

if uploaded_file:
    try:
        df_input = pd.read_excel(uploaded_file)
        
        # TJEK KOLONNER
        kr√¶vede_kolonner = ['Elevnavn', 'Elevid', '√ònsker']
        mangler = [col for col in kr√¶vede_kolonner if col not in df_input.columns]
        
        if mangler:
            st.error(f"‚ùå Fejl: Din fil mangler f√∏lgende kolonner: {', '.join(mangler)}")
            st.info("Tip: Brug 'Hent Skabelon' knappen for at se det korrekte format.")
        else:
            # K√òR BEREGNING
            tider_dict = parse_tider(specifikke_tider_raw)
            resultat = beregn_plan(
                df_input, 
                start_tid_input, 
                lokale_str, 
                tider_dict, 
                varighed, 
                lokale_buffer
            )
            
            if isinstance(resultat, str): # Det er en fejlbesked
                st.error(f"Der skete en fejl under beregningen: {resultat}")
            else:
                st.success("‚úÖ Planl√¶gningen er f√¶rdig!")
                
                # --- VIS RESULTATER ---
                tab1, tab2 = st.tabs(["üë®‚Äçüè´ L√¶reroversigt", "üéì Elevoversigt"])
                
                # Forbered l√¶rer-header
                resultat['L√¶rer_Visning'] = resultat['L√¶rer'] + " (" + resultat['Lokale'] + ")"
                
                with tab1:
                    st.markdown("**L√¶rernes tidsplan (Lokaler i parentes)**")
                    # Pivot: Index=Tid, Kolonner=L√¶rer, V√¶rdi=Elev
                    pivot_l√¶r = resultat.pivot(index='Start', columns='L√¶rer_Visning', values='Elevid')
                    st.dataframe(pivot_l√¶r.fillna(""), use_container_width=True)
                
                with tab2:
                    st.markdown("**Elevernes tidsplan**")
                    # Loop gennem klasser
                    klasser = sorted(resultat['Klasse'].unique())
                    for k in klasser:
                        with st.expander(f"Klasse {k}", expanded=False):
                            df_k = resultat[resultat['Klasse'] == k]
                            pivot_elev = df_k.pivot(index='Elevnavn', columns='L√¶rer_Visning', values='Start')
                            st.dataframe(pivot_elev.fillna(""), use_container_width=True)

                # --- EXCEL EXPORT ---
                output = io.BytesIO()
                with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                    # R√•t data ark
                    resultat.drop(columns=['Start_dt', 'Slut_dt', 'L√¶rer_Visning'], errors='ignore').to_excel(writer, sheet_name='R√•data', index=False)
                    
                    # L√¶rer ark
                    pivot_l√¶r.fillna("").to_excel(writer, sheet_name='L√¶reroversigt')
                    
                    # Elev ark (samlet)
                    elev_export = resultat.pivot(index=['Klasse','Elevnavn'], columns='L√¶rer_Visning', values='Start')
                    elev_export.fillna("").to_excel(writer, sheet_name='Elevoversigt')
                
                st.markdown("---")
                st.download_button(
                    label="üì• Download Samlet Plan (Excel)",
                    data=output.getvalue(),
                    file_name="F√¶rdig_Samtaleplan.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )

    except Exception as e:
        st.error(f"Kunne ikke l√¶se filen. Er det en gyldig Excel-fil? Fejl: {e}")
`
        },
      });
    </script>
  </body>
</html>
